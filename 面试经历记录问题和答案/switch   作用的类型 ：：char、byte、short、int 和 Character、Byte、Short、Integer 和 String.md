**面向对象的思想：** 在程序中使用对象来映射现实中的事物，使用对象的关系来描述事物之间的联系

**面向对象关系：**

**is-a**:苹果是水果，水果设置为父类，苹果设置为子类

**has-a:**学生有地址，Address类作为Student类的成员变量

**use-a**:骑自行车上班，上班是功能，声明为方法，自行车作为方法的参数】

**面向对象的三大特性：**

**封装：** 面向对象的核心思想，把**对象的属性和行为**封装起来，不需要让外界知道具体实现的细节

**继承：**主要描述类与类之间的关系，通过继承，可以无须编写原有类的情况下，对原有类进行扩展。

**多态：**是指在程序中允许出现**重名的现象**，他指一个类中定义的属性和方法被其他类继承后，他们可以有

​            不同的数据类型或者表现出不同的行为，这使得同一个属性和方法在不同的类中具有不同的语义。

​            允许不同子类型的对象对同一消息作出不同的响应。

**抽象：** 类是对某一事物的的抽象描述，而对象用于表现现实类中的个体。

**赋初值：** char=空字符，‘\u0000’    boolean=false    引用数据类型=null

# 访问控制的级别：

private---》default--》protected--》public

访问控制级别由小到大

**private（类访问级别）：** 被修饰的成员只能被**该类**的其他成员访问，**其他类无法访问**

**default（包访问级别）：** 这个类或者类的成员只能被**本包中的其他类访问**

**protected（子类访问级别）：** 被修饰的成员**既能被同一包下的其他类访问，也能被不同包下该类的**

​                                                      **子类访问**

**public（公共访问级别）**： 被修饰的可以被**所有类访问，不管访问类与被访问类是否在同一个包中**


# **一个类：**

成员变量

有构造方法：默认会有一个无参构造，如果写了构造，就不再提供无参构造，必须手动写出

构造方法也是可以*重载*的，方法名相同，参数列表不同。

构造方法之间也是可以互相调用的this(参数);

构造方法的调用只能放在第一行

# **this**：

代表当前对象。谁调用this所在的方法啊，this就代表谁。this.属性名，this.方法名(传入参数);this()

**注意：**只能在构造方法中使用this调用其他构造方法，不能在成员方法中使用。

​            在构造方法中，使用this必须在第一行，只能出现一次。

​             不能在一个类的两个构造方法中使用this互相调用

# 方法的重载：

在一个类中，方法名相同，但是参数列表不同（个数，类型，顺序，和**返回值类型没有关系**）

# **static**:

**静态变量**被所有的实例共享，只能修饰成员变量。不能修饰局部变量

**静态方法**不创建对象的情况下就调用某个方法，在静态方法中只能访问用static修饰的成员，原因在于

​                没有被static修饰的成员需要创建对象才能使用

**静态代码块**类被加载时会执行，类只加载一次，因此静态代码块只执行一次，通常使用程序代码块来

​                    对类的成员进行初始化。

 静态的，修饰方法，属性，（静态内部类），随着类的加载而加载，User.java--->编译User.class-->

运行的是class文件。User.class被加载到内容，Class这个类的对象，static修饰的变量这个时候就会

赋值了，静态的方法也可以调用了，static修饰的属性和方法已经被初始化ok了，就可以调用，用类名调用

特点：

随着类的加载而加载

优先于对象而存在

可以使用类名直接调用

**静态块（静态变量）——>成员变量——>构造方法——>静态方法** 

#  抽象类和接口

**抽象类（abstract)** ： 抽象方法必须用abstract来修饰

​                                      包含抽象方法必须声明为抽象类，但抽象类可以不含有抽象方法

​                                      抽象类中的成员可以是 private、默认、protected、public 

​                                      抽象类中可以定义构造器

​                                      抽象类中可以包含静态方法，也可以包含静态代码块

​                                    一个类只能继承一个类

**接口** ： 定义的方法默认使用**public abstract**来修饰

​              定义的变量默认使用**public static final**来修饰 

​             接口中不能定义构造器

​               方法全部都是抽象方法

​             接口中不能有静态方法

​             一个接可以通过**extends**继承多个接口，接口之间用逗号隔开

​            一个类可以实现(implements)多个接口

​           

**继承**：子类继承父类，extends关键字

子类就拥有了父类中非私有的属性和方法，构造方法不能继承

单继承：一类类只能继承一个类，不能同时继承多个类，但是可以实现多重继承，A-->B,B-->C

属性：如果在方法中（局部变量）,成员变量，父类中属性名字相同，在使用的时候，就近原则

构造方法：子类的构造方法默认在第一行调用父类的无参构造super();

如果父类没有无参构造，就需要手动调用父类的有参的构造

方法：如果子类于父类中的方法相同，就是方法的重写了。？

父类的方法的实现不能满足子类的需求了，子类就需要重写这个方法，来写子类特有的实现。

**方法的重写：**

1.方法名相同

2.参数也相同

3.子类重写之后的权限修饰符不能更低

4.子类重写之后抛异常不能更大

如果父类的方法强制只有父类的一种实现方法，子类只能直接调用，不能重写。就需要final关键字了：

**final**：修饰类，不能被继承

修饰属性，基本类型，值不能变化

引用类型，引用不能变化，对象的属性是可以变化的

常量：所有的字母都大写，如果有多个单词，中间用_连接

方法：不能被重写

如果父类的方法，所有的子类都有自己的实现，那么子类就需要重写该方法，并且是所有的子类都重写。父类的该方法的实现就

没有意义了。就可以不实现。就可以将该方法设置为抽象的方法

**abstract**： 权限修饰符  abstract返回值类型 方法名(参数); 没有方法体

抽象方法---》抽象类

抽象类： public abstract class 类名{}

不能实例化

有构造方法,给子类用的，子类初始化之前先初始化父类

可以有抽象方法，也可以没有抽象方法

1.如果抽象类中所有的方法都是非抽象的，适配器模式，自己不能实例化，所有里面的方法写了也没多大意义，必须有子类去继承

子类需要哪个方法就重写哪个方法

2.抽象类中所有的方法都是抽象方法：接口

interface:

都是public static final修饰的常量

方法public abstract 修饰的抽象方法（JDK8：default 返回值类型 方法名(参数){}

没有构造方法

不能实例化

可以多实现，一个类可以同时实现多个接口

一个接口可以同时继承多个接口

作用：相当于规则，标准，不同的实现类去实现。用户调用的时候，不关心具体的实现，只需要关注接口的具体功能。
 *

**switch   作用的类型 ：：** char、byte、short、int 和 他们对应的封装类Character、Byte、Short、Integer ，以及枚举（Enum）类型。**在java1.7之后也支持String类型**

构造方法的调用只能放在第一行，

this：代表当前对象，谁调用this

static：随着类加载而加载，优先于对象的存在，可以直接使用类名调用。

​            e



封装：





继承：构造方法不能继承  ，单继承，可以实现多继承，如果父类的方法强制只有父类的方式，不能重写，需要final关键字

final：修饰类

​           修饰属性

​            方法：不能被重写

抽象类 ：强制自己不能实例化

接口: 必须要有实现类



***多态：***可以提高类的扩展性

向上转型：Person p=new Boy()  不能调用子类特有的方法

向下转型:  Boy boy=(Boy)p

instanceof l来判断对象属于哪个类型