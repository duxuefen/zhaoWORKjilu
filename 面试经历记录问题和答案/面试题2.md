面试题2

![image-20200918084251801](C:\Users\du\AppData\Roaming\Typora\typora-user-images\image-20200918084251801.png)

**list和List<object>和List<?>的区别，泛型的上限和下限：**

**1.如何理解java**

答：Java是一门[面向对象](https://baike.baidu.com/item/面向对象)编程语言,Java具有简单性、面向对象、[分布式](https://baike.baidu.com/item/分布式/19276232)、[健壮性](https://baike.baidu.com/item/健壮性/4430133)、[安全性](https://baike.baidu.com/item/安全性/7664678)、平台独立与可移植性、[多线程](https://baike.baidu.com/item/多线程/1190404)、动态性等特点 

**2.怎么理解面向对象**

答：面向对象有三大特征：继承，封装，多态

​        继承：是从已有类的信息创建新类

**3.spring ioc怎么理解？**

答： ioc是一种 是一种编程思想，意思为控制反转，降低了耦合性，把设计好的对象交给spring容器管理，是通过Spring容器来管理对象的生命周期。由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象。

**4.pring创建对象的原理**

答：spring把所有的对象称为Bean，管理bean通过配置文件或注解，spring容器中bean默认以反射调用该类的无参构造方法创建对象。spring框架就通过class创建java对象，以id作为key，最后存放到了spring容器中，这个java对象就称为了spring容器中的Bean

**5.怎么理解线程安全和非线程安全？**

答：*线程：*进程想要执行任务需要依赖线程，

​       *多线程:* 串行（单线程执行任务）：按照一定的顺序去执行，他们不可能在时间上发生重叠。

​                     并行（多线程执行任务）：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意              上的，在同一时刻发生的，并行在时间上是重叠的。

​        *线程安全：*就是为了保证变量的安全。当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的

​      *确保线程安全：*  synchronize关键字：来控制线程同步

​                                  lock关键字：Lock lock=new RenntrantLock();

​                                                         lock.Lock();  //获取锁对象

​                                                         lock.unlock();

​                                                         *lock**.tryLock(**2**,TimeUnit.SECONDS)*  ；  // *// 如果2秒内获取不到锁对象，那就不再等待*

**6.如何理解事务**

答： 事务有4个特性：1.原子性： 要么成功，要么失败

​                                       2.一致性：一个事务执行之前和执行之后都必须处于一致性状态

​                                       3.隔离性：多个并发事务之间要相互隔离

​                                        4.持久性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的

​      事务的出错的情况：

​                                 1.脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

​                                 2.不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

​                                  3.虚读（幻读）：幻读是事务非独立执行时发生的一种现象

**数据库的四种事务隔离级别：**

​                                    1.read  uncommitted（读取未提交内容）也叫脏读

​                                     2.read commited  （读取提交内容）它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read）

                                    3.  repeatable  read(可重读) MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）
                                       4. serializable（可串行化）它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

  事务的分类：本地事务，全局事务

​                           编程式事务：通过编码方式，开启事务、提交事务、回滚事务

​                           声明性事务：通过xml配置或注解，实现事务管理。Spring AOP和EJB都是声明性事务 

​                           JTA事务，CMT事务

​    **spring的事务模型**:  为复杂的事务API提供了一致的编程模型，如JTA、JDBC、Hibernate、JPA                    和JDO

​                                    支持声明式事务管理

**7.异步请求和同步请求的理解**

答：普通B/S模式（同步）AJAX技术（异步）

  **同步**：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

  **异步**: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

同步交互，就是最常见的click-refresh模式，点一个连接或提交一个表单，然后整个页面被刷新

异步交互，当前很热的AJAX就是典型例子，提交请求返回对象是不可见的层，然后用javascripts根据返回数据，改变当前页面显示，譬如google map



**8.数据库中左外连接和右外连接和内连接的区别**

内连接：指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。

外连接：连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。

**9.==和equals的区别**

**静态代理和动态代理的区别**

答：静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。

​       静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道

​        动态代理是实现 JDK 里的 InvocationHandler 接口的 invoke 方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy 里的 newProxyInstance 得到代理对象。

        Invocation 调用，启用   invoke 援引，援用   proxy 英 [ˈprɒksi] 代理权 ，代理人



​      动态代理 CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行时，**动态修改字节码**达到修改类的目的。

​        AOP 编程就是基于动态代理实现的，比如著名的 Spring 框架、Hibernate 框架等等都是动态代理的使用例子。





**如何判断二个对象是否相等？**

答：比较hashCode的返回值是否相等，如果相等，然后再比较equals方法比较内容是否相同





**springMVC的工作原理**

答：a.  用户向服务器发送请求，请求被springMVC 前端控制器 DispatchServlet 捕获；

Dispatch 发送   servlet 程序

b. DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping

将请求映射到处理器 HandlerExcutionChain；

​     Handler 处理器   excution 执行  chain 链

c. DispatchServlet 根据获得 Handler 选择一个合适的HandlerAdapter 适配器处理；

Adapter 适配器

d. Handler 对数据处理完成以后将返回一个 ModelAndView（）对象给 DisPatchServlet;

e.  Handler 返回的 ModelAndView() 只是一个逻辑视图并不是一个正式的视图， DispatcherSevlet 通过

ViewResolver 视图解析器将逻辑视图转化为真正的视图View;

​    Resolver 解析器

h. DispatcherServle 通过 model 解析出 ModelAndView()中的参数进行解析最终展现出完整的 view 并返回给客户端;



